#===== Xml - START =====
#数据库配置
jdbc.url=jdbc:mysql://rm-bp102m1nm9117mfu1.mysql.rds.aliyuncs.com:3306/red_envelope?autoReconnect=true&useUnicode=true&characterEncoding=utf8
jdbc.username=root_red
jdbc.password=UBPm2u6gknjCue

jdbc.initialSize=3
jdbc.minIdle=3
jdbc.maxActive=150
jdbc.maxWait=60000


#requestId-缓存配置
requestId.redis.host=127.0.0.1
requestId.redis.port=6379
requestId.redis.timeout=10000
requestId.redis.database=1

#===== requestId pool config - START =====
#maxTotal 最大连接数, 默认8个
requestId.redis.maxTotal=100
#最小空闲连接数, 默认0；低于minIdle时，将创建新的链接
requestId.redis.minIdle=2
#maxIdle，控制一个pool最多有多少个状态为idle(空闲的)的jedis实例；空闲链接数大于maxIdle时，将进行回收
requestId.redis.maxIdle=20
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
requestId.redis.maxWaitMillis=-1
#连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true
requestId.redis.blockWhenExhausted=true
#timeBetweenEvictionRunsMillis，逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
requestId.redis.timeBetweenEvictionRunsMillis=2000
#minEvictableIdleTimeMillis，逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
requestId.redis.minEvictableIdleTimeMillis=5000
#在获取连接的时候检查有效性, 默认false
requestId.redis.testOnBorrow=true
#在空闲时检查有效性, 默认false
requestId.redis.testWhileIdle=false
#===== requestId pool config - END =====


#SESSION缓存配置
session.cache.redis.host=127.0.0.1
session.cache.redis.port=6379
session.cache.redis.timeout=10000
session.cache.redis.database=2

#===== session pool config - START =====
#maxTotal 最大连接数, 默认8个
session.cache.redis.maxTotal=100
#最小空闲连接数, 默认0；低于minIdle时，将创建新的链接
session.cache.redis.minIdle=2
#maxIdle，控制一个pool最多有多少个状态为idle(空闲的)的jedis实例；空闲链接数大于maxIdle时，将进行回收
session.cache.redis.maxIdle=20
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
session.cache.redis.maxWaitMillis=-1
#连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true
session.cache.redis.blockWhenExhausted=true
#timeBetweenEvictionRunsMillis，逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
session.cache.redis.timeBetweenEvictionRunsMillis=2000
#minEvictableIdleTimeMillis，逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
session.cache.redis.minEvictableIdleTimeMillis=5000
#在获取连接的时候检查有效性, 默认false
session.cache.redis.testOnBorrow=true
#在空闲时检查有效性, 默认false
session.cache.redis.testWhileIdle=false
#===== session pool config - END =====


#红包缓存配置
hongbao.redis.host=127.0.0.1
hongbao.redis.port=6379
hongbao.redis.timeout=10000
hongbao.redis.database=3

#===== hongbao pool config - START =====
#maxTotal 最大连接数, 默认8个
hongbao.redis.maxTotal=100
#最小空闲连接数, 默认0；低于minIdle时，将创建新的链接
hongbao.redis.minIdle=2
#maxIdle，控制一个pool最多有多少个状态为idle(空闲的)的jedis实例；空闲链接数大于maxIdle时，将进行回收
hongbao.redis.maxIdle=20
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
hongbao.redis.maxWaitMillis=-1
#连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true
hongbao.redis.blockWhenExhausted=true
#timeBetweenEvictionRunsMillis，逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
hongbao.redis.timeBetweenEvictionRunsMillis=2000
#minEvictableIdleTimeMillis，逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
hongbao.redis.minEvictableIdleTimeMillis=5000
#在获取连接的时候检查有效性, 默认false
hongbao.redis.testOnBorrow=true
#在空闲时检查有效性, 默认false
hongbao.redis.testWhileIdle=false
#===== hongbao pool config - END =====


#user-缓存配置
user.redis.host=127.0.0.1
user.redis.port=6379
user.redis.timeout=10000
user.redis.database=5

#===== user pool config - START =====
#maxTotal 最大连接数, 默认8个
user.redis.maxTotal=100
#最小空闲连接数, 默认0；低于minIdle时，将创建新的链接
user.redis.minIdle=2
#maxIdle，控制一个pool最多有多少个状态为idle(空闲的)的jedis实例；空闲链接数大于maxIdle时，将进行回收
user.redis.maxIdle=20
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
user.redis.maxWaitMillis=-1
#连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true
user.redis.blockWhenExhausted=true
#timeBetweenEvictionRunsMillis，逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
user.redis.timeBetweenEvictionRunsMillis=2000
#minEvictableIdleTimeMillis，逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
user.redis.minEvictableIdleTimeMillis=5000
#在获取连接的时候检查有效性, 默认false
user.redis.testOnBorrow=true
#在空闲时检查有效性, 默认false
user.redis.testWhileIdle=false
#===== user pool config - END =====


#图形验证码-缓存配置
captcha.redis.host=127.0.0.1
captcha.redis.port=6379
captcha.redis.timeout=10000
captcha.redis.database=6

#===== captcha pool config - START =====
#maxTotal 最大连接数, 默认8个
captcha.redis.maxTotal=100
#最小空闲连接数, 默认0；低于minIdle时，将创建新的链接
captcha.redis.minIdle=2
#maxIdle，控制一个pool最多有多少个状态为idle(空闲的)的jedis实例；空闲链接数大于maxIdle时，将进行回收
captcha.redis.maxIdle=20
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
captcha.redis.maxWaitMillis=-1
#连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true
captcha.redis.blockWhenExhausted=true
#timeBetweenEvictionRunsMillis，逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
captcha.redis.timeBetweenEvictionRunsMillis=2000
#minEvictableIdleTimeMillis，逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
captcha.redis.minEvictableIdleTimeMillis=5000
#在获取连接的时候检查有效性, 默认false
captcha.redis.testOnBorrow=true
#在空闲时检查有效性, 默认false
captcha.redis.testWhileIdle=false
#===== captcha pool config - END =====


#banner缓存配置
banner.redis.host=127.0.0.1
banner.redis.port=6379
banner.redis.timeout=10000
banner.redis.database=9

#===== banner pool config - START =====
#maxTotal 最大连接数, 默认8个
banner.redis.maxTotal=100
#最小空闲连接数, 默认0；低于minIdle时，将创建新的链接
banner.redis.minIdle=2
#maxIdle，控制一个pool最多有多少个状态为idle(空闲的)的jedis实例；空闲链接数大于maxIdle时，将进行回收
banner.redis.maxIdle=20
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
banner.redis.maxWaitMillis=-1
#连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true
banner.redis.blockWhenExhausted=true
#timeBetweenEvictionRunsMillis，逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
banner.redis.timeBetweenEvictionRunsMillis=2000
#minEvictableIdleTimeMillis，逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
banner.redis.minEvictableIdleTimeMillis=5000
#在获取连接的时候检查有效性, 默认false
banner.redis.testOnBorrow=true
#在空闲时检查有效性, 默认false
banner.redis.testWhileIdle=false
#===== banner pool config - END =====


#welfare缓存配置
welfare.redis.host=127.0.0.1
welfare.redis.port=6379
welfare.redis.timeout=10000
welfare.redis.database=10

#===== welfare pool config - START =====
#maxTotal 最大连接数, 默认8个
welfare.redis.maxTotal=100
#最小空闲连接数, 默认0；低于minIdle时，将创建新的链接
welfare.redis.minIdle=2
#maxIdle，控制一个pool最多有多少个状态为idle(空闲的)的jedis实例；空闲链接数大于maxIdle时，将进行回收
welfare.redis.maxIdle=20
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
welfare.redis.maxWaitMillis=-1
#连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true
welfare.redis.blockWhenExhausted=true
#timeBetweenEvictionRunsMillis，逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
welfare.redis.timeBetweenEvictionRunsMillis=2000
#minEvictableIdleTimeMillis，逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
welfare.redis.minEvictableIdleTimeMillis=5000
#在获取连接的时候检查有效性, 默认false
welfare.redis.testOnBorrow=true
#在空闲时检查有效性, 默认false
welfare.redis.testWhileIdle=false
#===== welfare pool config - END =====


#version缓存配置
version.redis.host=127.0.0.1
version.redis.port=6379
version.redis.timeout=10000
version.redis.database=11

#===== version pool config - START =====
#maxTotal 最大连接数, 默认8个
version.redis.maxTotal=100
#最小空闲连接数, 默认0；低于minIdle时，将创建新的链接
version.redis.minIdle=2
#maxIdle，控制一个pool最多有多少个状态为idle(空闲的)的jedis实例；空闲链接数大于maxIdle时，将进行回收
version.redis.maxIdle=20
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
version.redis.maxWaitMillis=-1
#连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true
version.redis.blockWhenExhausted=true
#timeBetweenEvictionRunsMillis，逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
version.redis.timeBetweenEvictionRunsMillis=2000
#minEvictableIdleTimeMillis，逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
version.redis.minEvictableIdleTimeMillis=5000
#在获取连接的时候检查有效性, 默认false
version.redis.testOnBorrow=true
#在空闲时检查有效性, 默认false
version.redis.testWhileIdle=false
#===== version pool config - END =====


#android积分墙缓存配置
android.redis.host=127.0.0.1
android.redis.port=6379
android.redis.timeout=10000
android.redis.database=12

#===== android pool config - START =====
#maxTotal 最大连接数, 默认8个
android.redis.maxTotal=100
#最小空闲连接数, 默认0；低于minIdle时，将创建新的链接
android.redis.minIdle=2
#maxIdle，控制一个pool最多有多少个状态为idle(空闲的)的jedis实例；空闲链接数大于maxIdle时，将进行回收
android.redis.maxIdle=20
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
android.redis.maxWaitMillis=-1
#连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true
android.redis.blockWhenExhausted=true
#timeBetweenEvictionRunsMillis，逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
android.redis.timeBetweenEvictionRunsMillis=2000
#minEvictableIdleTimeMillis，逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
android.redis.minEvictableIdleTimeMillis=5000
#在获取连接的时候检查有效性, 默认false
android.redis.testOnBorrow=true
#在空闲时检查有效性, 默认false
android.redis.testWhileIdle=false
#===== android pool config - END =====


#悬赏任务缓存配置
xuanshang.redis.host=127.0.0.1
xuanshang.redis.port=6379
xuanshang.redis.timeout=10000
xuanshang.redis.database=13

#===== xuanshang pool config - START =====
#maxTotal 最大连接数, 默认8个
xuanshang.redis.maxTotal=100
#最小空闲连接数, 默认0；低于minIdle时，将创建新的链接
xuanshang.redis.minIdle=2
#maxIdle，控制一个pool最多有多少个状态为idle(空闲的)的jedis实例；空闲链接数大于maxIdle时，将进行回收
xuanshang.redis.maxIdle=20
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
xuanshang.redis.maxWaitMillis=-1
#连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true
xuanshang.redis.blockWhenExhausted=true
#timeBetweenEvictionRunsMillis，逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
xuanshang.redis.timeBetweenEvictionRunsMillis=2000
#minEvictableIdleTimeMillis，逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
xuanshang.redis.minEvictableIdleTimeMillis=5000
#在获取连接的时候检查有效性, 默认false
xuanshang.redis.testOnBorrow=true
#在空闲时检查有效性, 默认false
xuanshang.redis.testWhileIdle=false
#===== xuanshang pool config - END =====


#ios任务缓存配置
ios.redis.host=127.0.0.1
ios.redis.port=6379
ios.redis.timeout=10000
ios.redis.database=14

#===== ios pool config - START =====
#maxTotal 最大连接数, 默认8个
ios.redis.maxTotal=100
#最小空闲连接数, 默认0；低于minIdle时，将创建新的链接
ios.redis.minIdle=2
#maxIdle，控制一个pool最多有多少个状态为idle(空闲的)的jedis实例；空闲链接数大于maxIdle时，将进行回收
ios.redis.maxIdle=20
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
ios.redis.maxWaitMillis=-1
#连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true
ios.redis.blockWhenExhausted=true
#timeBetweenEvictionRunsMillis，逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1
ios.redis.timeBetweenEvictionRunsMillis=2000
#minEvictableIdleTimeMillis，逐出连接的最小空闲时间 默认1800000毫秒(30分钟)
ios.redis.minEvictableIdleTimeMillis=5000
#在获取连接的时候检查有效性, 默认false
ios.redis.testOnBorrow=true
#在空闲时检查有效性, 默认false
ios.redis.testWhileIdle=false
#===== ios pool config - END =====





#===== Xml - END =====

#===== Config - START =====

#微信绑定说明页
weixinBindUrl=http://dev.163aigou.com/c/p/bind/bindDetail

#红包域名
redBaseUrl=http://dev.163aigou.com
#redBaseUrl=http://192.168.2.100:8088

#允许访问的版本，按,分割
supportedVersion=1.0.0

#开发模式，仅本地开发环境时，设置为true
devModel=true

#调试模式，则生产环境也可以使用，有可能可以输出更多信息
debug=true

#当前服务运行的服务器所在环境位置:如果是非阿里云中,就填空白
#否则如果当前运行在阿里云杭州的ECS中,就填写cn-hangzhou
#其他阿里云区域填写对应的区域region:cn-beijing / cn-hongkong / cn-shanghai / cn-shenzhen / cn-qingdao / us-west-1(美国硅谷) / ap-southeast-1(亚太(新加坡))
serverRuntimeRegion=cn-hangzhou

#临时文件目录，一定以“分隔符”结尾
tmpDirectory=/tmp/hongbao_app/

#security - START
#是否真是发送短信（开发环境时，可能不需要发送短信）
security.realSms=true

#请求中的时间戳与服务器时间允许的最大误差（单位毫秒），小于等于0：表示不验证时间戳
security.timeDeviation=0

#一个手机号每小时只能发送验证码短信设定条数，测试环境，阀值较大
security.verifySmsMaxCountOneHour=100

#一个手机号24小时只能发送验证码短信设定条数，测试环境，阀值较大
security.verifySmsMaxCountOneDay=500

#一个IP地址每小时只能发送验证码短信设定条数，测试环境，阀值较大
security.verifySmsMaxCountForIpOneHour=200

#一个IP地址24小时只能发送验证码短信设定条数，测试环境，阀值较大
security.verifySmsMaxCountForIpOneDay=1000

#短信验证码的有效时长的毫秒数，默认5分钟
security.smsVerifyCodeExpiredTime=300000
#短信验证码的Token有效时长的毫秒数，默认1小时
security.smsVerifyTokenExpiredTime=3600000

#security - END


#aliyun oss
aliyunOss.accessKeyId=kpjpBeIsyFWSjSvw
aliyunOss.accessKeySecret=QSO1a68D3GXcLz5jm7TYYRdt6JaabT
#OSS所在的物理区域("oss-"+区域名), 生成endpoint时,会直接拼接在域名上
aliyunOss.region=oss-cn-hangzhou
aliyunOss.bucketName=ag-aw-test

aliyunOss.stsRoleArn=acs:ram::1399766284432007:role/sts-appuser-creater-role
#token有效期，支持900~3600（15分钟(900)～1小时(3600)）（单位：秒）
aliyunOss.stsTokenDurationSeconds=3600
#用户上传图片文件到OSS的 路径，%s表示当前用户的openId(一定不要以"/"开头,且一定以"/"结尾)
aliyunOss.userImgPath=i/%s/
#用户上传视频文件到OSS的 路径，%s表示当前用户的openId(一定不要以"/"开头,且一定以"/"结尾)
aliyunOss.userVideoPath=v/%s/

#CDN加速域名,支持所有类型的文件的CDN加速访问
aliyunOss.cdnName=http://dev.image.163aigou.com/
#图片专有CDN域名(支持图片动态压缩;支持CDN加速),只支持图片文件的CDN加速访问
aliyunOss.imgCdnName=http://dev.image.163aigou.com/
#阿里云外网域名后面部分, endpoint则就直接把region拼接在前面
aliyunOss.domain=.aliyuncs.com
#阿里云内网域名后面部分, endpoint则就直接把region拼接在前面
aliyunOss.internalDomain=-internal.aliyuncs.com

aliyunOss.imgHost=https://ag-aw-test.oss-cn-hangzhou.aliyuncs.com/
aliyunOss.newCdnName=https://oss-cn-hangzhou.aliyuncs.com/

#===== Config - END =====
